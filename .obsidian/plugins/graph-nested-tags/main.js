/*
THIS IS A GENERATED/BUNDLED FILE BY ESBUILD
if you want to view the source, please visit the github repository of this plugin
*/

var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// src/main.ts
var main_exports = {};
__export(main_exports, {
  default: () => GraphNestedTagsPlugin
});
module.exports = __toCommonJS(main_exports);
var import_obsidian = require("obsidian");

// src/settings.ts
var DEFAULT_SETTINGS = {
  // 空默认设置
};

// src/main.ts
var GraphNestedTagsPlugin = class extends import_obsidian.Plugin {
  // inject our own wrapper around graphLeaf.view.renderer.setData
  // which will manipulate add tag -> subtag hierarchy  
  inject_setData(graphLeaf) {
    const leafRenderer = graphLeaf.view.renderer;
    if (leafRenderer.originalSetData == void 0) {
      leafRenderer.originalSetData = leafRenderer.setData;
    }
    leafRenderer.setData = (data) => {
      var _a, _b;
      try {
        const nodes = data.nodes;
        const nestedTags = [];
        for (const id in nodes) {
          if (nodes[id].type === "tag" && id.includes("|")) {
            nestedTags.push(id);
          }
        }
        for (const nestedTagId of nestedTags) {
          const tagParts = nestedTagId.split("|");
          for (let i = 0; i < tagParts.length; i++) {
            const currentTag = tagParts[i];
            const cleanName = currentTag.replace(/^#/, "");
            if (!(currentTag in nodes)) {
              nodes[currentTag] = {
                type: "tag",
                links: {},
                path: cleanName,
                name: cleanName,
                displayText: cleanName,
                // 添加更多可能影响显示的属性
                title: cleanName,
                label: cleanName,
                text: cleanName,
                id: currentTag,
                // 保持原始ID用于引用
                displayName: cleanName
              };
            } else {
              const existingNode = nodes[currentTag];
              existingNode.path = cleanName;
              existingNode.name = cleanName;
              existingNode.displayText = cleanName;
              existingNode.title = cleanName;
              existingNode.label = cleanName;
              existingNode.text = cleanName;
              existingNode.displayName = cleanName;
            }
            if (i > 0) {
              const parentTag = tagParts[i - 1];
              if (!nodes[parentTag].links)
                nodes[parentTag].links = {};
              if (!nodes[currentTag].links)
                nodes[currentTag].links = {};
              nodes[parentTag].links[currentTag] = true;
              nodes[currentTag].links[parentTag] = true;
            }
          }
          const leafTagName = tagParts[tagParts.length - 1];
          for (const nodeId in nodes) {
            const node = nodes[nodeId];
            if (node.links && node.links[nestedTagId]) {
              if (!nodes[leafTagName].links)
                nodes[leafTagName].links = {};
              node.links[leafTagName] = node.links[nestedTagId];
              delete node.links[nestedTagId];
            }
          }
          delete nodes[nestedTagId];
        }
        for (const nodeId in nodes) {
          const node = nodes[nodeId];
          if (node.type === "tag" && nodeId.startsWith("#")) {
            const cleanName = nodeId.replace(/^#/, "");
            node.path = cleanName;
            node.name = cleanName;
            node.displayText = cleanName;
            node.title = cleanName;
            node.label = cleanName;
            node.text = cleanName;
            node.displayName = cleanName;
          }
        }
        return (_a = leafRenderer.originalSetData) == null ? void 0 : _a.call(leafRenderer, data);
      } catch (error) {
        console.error("Graph Nested Tags Plugin Error:", error);
        return (_b = leafRenderer.originalSetData) == null ? void 0 : _b.call(leafRenderer, data);
      }
    };
    return graphLeaf;
  }
  async onload() {
    await this.loadSettings();
    this.registerEvent(
      this.app.workspace.on("layout-change", () => {
        for (const leaf of this.app.workspace.getLeavesOfType("graph")) {
          if (leaf.view.renderer.originalSetData === void 0) {
            this.inject_setData(leaf);
          }
        }
      })
    );
  }
  onunload() {
    for (const leaf of this.app.workspace.getLeavesOfType(
      "graph"
    )) {
      if (leaf.view.renderer.originalSetData) {
        leaf.view.renderer.setData = leaf.view.renderer.originalSetData;
        delete leaf.view.renderer.originalSetData;
        leaf.view.unload();
        leaf.view.load();
      }
    }
  }
  async loadSettings() {
    const loadedData = await this.loadData();
    this.settings = Object.assign({}, DEFAULT_SETTINGS, loadedData);
  }
  async saveSettings() {
    await this.saveData(this.settings);
  }
};
